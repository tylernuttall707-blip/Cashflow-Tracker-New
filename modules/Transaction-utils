// Transaction Expansion & Override Utilities

/**
 * Expands a recurring transaction into individual instances
 */
export function expandRecurringTransaction(transaction, viewStartDate, viewEndDate) {
  if (!transaction.recurring) {
    // One-time transaction - return as single instance
    return [{
      id: `${transaction.id}-${transaction.date}`,
      parentId: transaction.id,
      parentType: 'oneOff',
      instanceDate: transaction.date,
      name: transaction.name,
      category: transaction.category,
      amount: transaction.amount,
      type: transaction.type,
      isRecurring: false,
      isModified: false
    }];
  }

  const instances = [];
  const start = new Date(Math.max(new Date(transaction.startDate), new Date(viewStartDate)));
  const end = new Date(Math.min(new Date(transaction.endDate || viewEndDate), new Date(viewEndDate)));

  switch (transaction.frequency) {
    case 'daily':
      generateDailyInstances(transaction, start, end, instances);
      break;
    case 'weekly':
      generateWeeklyInstances(transaction, start, end, instances);
      break;
    case 'biweekly':
      generateBiweeklyInstances(transaction, start, end, instances);
      break;
    case 'monthly':
      generateMonthlyInstances(transaction, start, end, instances);
      break;
  }

  return instances;
}

function generateDailyInstances(transaction, start, end, instances) {
  let currentDate = new Date(start);
  
  while (currentDate <= end) {
    if (!transaction.skipWeekends || !isWeekend(currentDate)) {
      instances.push(createInstance(transaction, currentDate));
    }
    currentDate.setDate(currentDate.getDate() + 1);
  }
}

function generateWeeklyInstances(transaction, start, end, instances) {
  const startDate = new Date(transaction.startDate);
  let currentDate = new Date(start);
  
  // Find the first occurrence on or after start date
  const dayOfWeek = transaction.dayOfWeek?.[0] || startDate.getDay();
  while (currentDate.getDay() !== dayOfWeek && currentDate <= end) {
    currentDate.setDate(currentDate.getDate() + 1);
  }
  
  while (currentDate <= end) {
    instances.push(createInstance(transaction, currentDate));
    currentDate.setDate(currentDate.getDate() + 7);
  }
}

function generateBiweeklyInstances(transaction, start, end, instances) {
  const startDate = new Date(transaction.startDate);
  let currentDate = new Date(startDate);
  
  // Fast forward to first occurrence in view range
  while (currentDate < start) {
    currentDate.setDate(currentDate.getDate() + 14);
  }
  
  while (currentDate <= end) {
    instances.push(createInstance(transaction, currentDate));
    currentDate.setDate(currentDate.getDate() + 14);
  }
}

function generateMonthlyInstances(transaction, start, end, instances) {
  let currentDate = new Date(start);
  
  // Adjust to the correct day of month
  if (transaction.monthlyMode === 'day' && transaction.dayOfMonth) {
    currentDate.setDate(transaction.dayOfMonth);
    if (currentDate < start) {
      currentDate.setMonth(currentDate.getMonth() + 1);
    }
  }
  
  while (currentDate <= end) {
    instances.push(createInstance(transaction, currentDate));
    currentDate.setMonth(currentDate.getMonth() + 1);
  }
}

function createInstance(transaction, date) {
  const dateStr = formatDate(date);
  const amount = getAmountForDate(transaction, dateStr);
  
  return {
    id: `${transaction.id}-${dateStr}`,
    parentId: transaction.id,
    parentType: transaction.type === 'income' ? 'incomeStream' : 'oneOff',
    instanceDate: dateStr,
    name: transaction.name,
    category: transaction.category,
    amount: amount,
    type: transaction.type,
    isRecurring: true,
    isModified: false
  };
}

/**
 * Gets the amount for a transaction on a specific date, considering step changes
 */
function getAmountForDate(transaction, date) {
  if (!transaction.steps || transaction.steps.length === 0) {
    return transaction.amount;
  }
  
  // Find the most recent step that applies
  const applicableSteps = transaction.steps
    .filter(step => step.effectiveFrom <= date)
    .sort((a, b) => b.effectiveFrom.localeCompare(a.effectiveFrom));
  
  return applicableSteps.length > 0 
    ? applicableSteps[0].amount 
    : transaction.amount;
}

/**
 * Applies overrides to expanded transaction instances
 */
export function applyOverrides(instances, overrides) {
  const overrideMap = new Map();
  
  // Create lookup map for fast access
  overrides.forEach(override => {
    const key = `${override.parentId}-${override.instanceDate}`;
    overrideMap.set(key, override);
  });
  
  return instances
    .map(instance => {
      const key = `${instance.parentId}-${instance.instanceDate}`;
      const override = overrideMap.get(key);
      
      if (!override) {
        return instance;
      }
      
      if (override.deleted) {
        return null; // Mark for filtering
      }
      
      // Apply modifications
      return {
        ...instance,
        ...override.modifications,
        isModified: true,
        overrideId: override.id
      };
    })
    .filter(instance => instance !== null); // Remove deleted instances
}

/**
 * Expands all transactions from the full data structure
 */
export function expandAllTransactions(data) {
  const { settings, oneOffs, incomeStreams } = data;
  const allInstances = [];
  
  // Expand one-offs (both recurring and one-time)
  oneOffs.forEach(transaction => {
    const instances = expandRecurringTransaction(
      transaction,
      settings.startDate,
      settings.endDate
    );
    allInstances.push(...instances);
  });
  
  // Expand income streams
  incomeStreams.forEach(stream => {
    const transaction = {
      ...stream,
      recurring: true,
      type: 'income'
    };
    const instances = expandRecurringTransaction(
      transaction,
      settings.startDate,
      settings.endDate
    );
    allInstances.push(...instances);
  });
  
  return allInstances;
}

/**
 * Gets the master transaction table data (expanded + overrides applied)
 */
export function getMasterTransactionTable(data) {
  const expanded = expandAllTransactions(data);
  const withOverrides = applyOverrides(expanded, data.transactionOverrides || []);
  
  // Sort by date
  return withOverrides.sort((a, b) => 
    a.instanceDate.localeCompare(b.instanceDate)
  );
}

/**
 * Saves an override for a specific transaction instance
 */
export function saveOverride(data, parentId, instanceDate, modifications) {
  if (!data.transactionOverrides) {
    data.transactionOverrides = [];
  }
  
  // Check if override already exists
  const existingIndex = data.transactionOverrides.findIndex(
    o => o.parentId === parentId && o.instanceDate === instanceDate
  );
  
  const override = {
    id: existingIndex >= 0 
      ? data.transactionOverrides[existingIndex].id 
      : generateId(),
    parentId,
    parentType: 'oneOff', // You'd determine this from the actual parent
    instanceDate,
    modifications,
    deleted: false
  };
  
  if (existingIndex >= 0) {
    // Update existing override
    data.transactionOverrides[existingIndex] = override;
  } else {
    // Add new override
    data.transactionOverrides.push(override);
  }
  
  return data;
}

/**
 * Marks a transaction instance as deleted
 */
export function deleteInstance(data, parentId, instanceDate) {
  return saveOverride(data, parentId, instanceDate, { deleted: true });
}

/**
 * Removes an override, reverting to the original recurring rule
 */
export function revertOverride(data, overrideId) {
  if (!data.transactionOverrides) {
    return data;
  }
  
  data.transactionOverrides = data.transactionOverrides.filter(
    o => o.id !== overrideId
  );
  
  return data;
}

// Helper functions

function isWeekend(date) {
  const day = date.getDay();
  return day === 0 || day === 6;
}

function formatDate(date) {
  return date.toISOString().split('T')[0];
}

function generateId() {
  return Math.random().toString(36).substr(2, 9);
}

/**
 * Example usage:
 * 
 * // Load your data
 * const data = JSON.parse(cashflowJSON);
 * 
 * // Get master table
 * const masterTable = getMasterTransactionTable(data);
 * 
 * // User edits Nov 26 Card 2752 payment
 * saveOverride(data, 'l1qb7kp', '2025-11-26', { amount: 15000 });
 * 
 * // User deletes Dec 10 Card 5641 payment
 * deleteInstance(data, 'p13rvsl', '2025-12-10');
 * 
 * // Refresh master table
 * const updatedTable = getMasterTransactionTable(data);
 */


